# How to Get Trading Points

## Overview

Trading points are **entry signals** generated by strategies when specific market conditions are met. This guide explains exactly when and how trading points are detected in the system.

---

## When Trading Points Are Generated

Trading points are checked **every time a new candle closes** on the strategy's timeframe.

### Flow:
```
New Candle Closes
    ↓
TradeEngine.__update_next_kline__()
    ↓
Trader.on_kline(tf, kline)
    ↓
Strategy.update(tf)
    ↓
Strategy.check_signal()  ← Trading point detection happens here
    ↓
Order Created (if conditions met)
```

---

## Step-by-Step: Breakout Strategy Trading Points

### BUY Signal Detection

```python
def check_signal(self):
    chart = self.tfs_chart[self.tf]
    last_kline = chart.iloc[-1]  # Latest completed candle
    
    # Step 1: Volume Filter
    if last_kline["Volume"] < self.params["vol_ratio_ma"] * self.ma_vol.iloc[-1]:
        return  # No signal if volume too low
    
    # Step 2: Find consolidation pattern using ZigZag
    idx = 1
    while idx < len(self.zz_points):
        zz_point_1 = self.zz_points[-idx]
        zz_point_2 = self.zz_points[-idx - 1]
        # Calculate price change between zigzag points
        if zz_point_2.ptype == POKE_POINT:
            change = (zz_point_1.pline.high - zz_point_2.pline.low) / zz_point_2.pline.low
        else:
            change = (zz_point_2.pline.high - zz_point_1.pline.low) / zz_point_2.pline.high
        
        # If change is too large, we've found the pattern boundary
        if change > self.params["zz_dev"] * self.min_zz_ratio:
            break
        idx += 1
    
    # Step 3: Check minimum consolidation period
    n_df = chart[self.zz_points[-idx].pidx : -1]
    if len(n_df) < self.params["min_num_cuml"]:
        return  # Pattern too short
    
    # Step 4: Extract swing points for trend lines
    n_last_poke_points = []  # Lows
    n_last_peak_points = []  # Highs
    for i, kline in n_df.iterrows():
        n_last_poke_points.append((i, kline["Low"]))
        n_last_peak_points.append((i, kline["High"]))
    
    # Step 5: Check candle body strength
    kline_body_pct = n_df[["Open", "Close"]].max(axis=1) - n_df[["Open", "Close"]].min(axis=1)
    mean_kline_body = kline_body_pct.mean()
    if abs(last_kline["Close"] - last_kline["Open"]) < self.params["kline_body_ratio"] * mean_kline_body:
        return  # Candle body too weak
    
    # Step 6: Calculate trend lines
    self.up_trend_line = find_uptrend_line(n_last_poke_points)  # Support line
    self.down_trend_line = find_downtrend_line(n_last_peak_points)  # Resistance line
    
    # Step 7: Check if lines converge (consolidation pattern)
    delta_end = abs(self.down_trend_line[1][1] - self.up_trend_line[1][1]) / self.up_trend_line[1][1]
    if delta_end > self.params["zz_dev"] * self.min_zz_ratio:
        return  # Lines don't converge, not a consolidation
    
    # Step 8: Check for BUY signal (green candle)
    if last_kline["Close"] > last_kline["Open"]:  # Green candle
        # Upper wick check (should be small)
        if (last_kline["High"] - last_kline["Close"]) > 0.5 * (last_kline["High"] - last_kline["Low"]):
            return  # Too much upper wick
        
        # Check if price broke above down trend line
        y_down_pct = get_y_on_line(self.down_trend_line, self.down_trend_line[1][0] + 1)
        
        # Final confirmation: price above trend line AND above SMA(200)
        if last_kline["Close"] > y_down_pct and last_kline["Close"] > ta.stream.SMA(chart["Close"], 200):
            # ✅ TRADING POINT DETECTED!
            sl = self.up_trend_line[1][1]  # Stop loss at support
            order = Order(OrderType.MARKET, OrderSide.BUY, last_kline["Close"], sl=sl)
            # ... create trade
```

### Key Conditions for BUY Trading Point:

1. ✅ Volume > `vol_ratio_ma × MA(volume)`
2. ✅ Consolidation pattern found (ZigZag analysis)
3. ✅ Minimum `min_num_cuml` candles in consolidation
4. ✅ Candle body > `kline_body_ratio × average_body`
5. ✅ Green candle with small upper wick (< 50% of range)
6. ✅ Price breaks above down trend line
7. ✅ Price above SMA(200)
8. ✅ Trend lines converge (triangle pattern)

---

## Step-by-Step: MACD Divergence Trading Points

### Hidden Divergence BUY Signal

```python
def check_signal(self):
    chart = self.tfs_chart[self.tf]
    last_kline = chart.iloc[-1]
    last_zz_point = self.zz_points[-1]
    
    # Step 1: Check if already processed
    if last_zz_point.pidx in self.checked_pidx:
        return
    
    # Step 2: Check trend direction
    # Calculate trend using n_trend_point ZigZag points
    up_pct, down_pct = calculate_trend(self.zz_points, self.params["n_trend_point"])
    
    # Step 3: For BUY, we need a POKE_POINT (swing low)
    if last_zz_point.ptype == POINT_TYPE.POKE_POINT:
        # Check trend is down (for hidden divergence)
        if up_pct > 0:  # Uptrend, skip
            return
        
        # Check MACD signal line
        if self.macd.iloc[-1] < self.macdsignal.iloc[-1]:
            return  # MACD below signal, not bullish
        
        # Step 4: Find previous swing lows
        n_zz_points = []
        i = 1
        while 2 * i + 1 <= len(self.zz_points):
            current_zz_point = self.zz_points[-(2 * i + 1)]
            # Find lower lows (for hidden divergence)
            if current_zz_point.pline.low < last_zz_point.pline.low:
                n_zz_points.append(current_zz_point)
            if len(n_zz_points) >= self.params["n_last_point"]:
                break
            i += 1
        
        # Step 5: Filter valid points (check trend line fit)
        valid_points_idx = self.filter_poke_points(n_zz_points, last_zz_point)
        
        # Step 6: Check each valid point for divergence
        for valid_point_idx in valid_points_idx:
            zz_point = n_zz_points[valid_point_idx]
            
            # Check price delta
            if (last_zz_point.pline.low - zz_point.pline.low) < self.delta_price_ratio * zz_point.pline.low:
                continue  # Price change too small
            
            # Step 7: Find MACD values at swing points
            max_high_idx = get_next_zz_point(zz_point)
            low_1_idx = self.macd_type.iloc[zz_point.pidx : max_high_idx].idxmin()
            low_2_idx = self.macd_type.iloc[self.zz_points[-2].pidx : len(chart)].idxmin()
            
            # Step 8: Check MACD divergence
            # Price: Higher low (last > zz_point) ✓
            # MACD: Lower low (last < zz_point) → Divergence!
            if self.macd_type.iloc[low_1_idx] > self.macd_type.iloc[low_2_idx] + self.delta_macd:
                # ✅ HIDDEN DIVERGENCE DETECTED!
                
                # Calculate stop loss and take profit
                sl = min(chart.iloc[last_zz_point.pidx :]["Low"].min(), last_zz_point.pline.low)
                tp = get_y_on_line(self.down_trend_line, len(chart))
                
                order = Order(OrderType.MARKET, OrderSide.BUY, last_kline["Close"], tp=tp, sl=sl)
                
                # Step 9: Risk/Reward validation
                if order.rr >= self.params["min_rr"] and order.reward_ratio > self.min_reward_ratio:
                    # ✅ TRADING POINT CONFIRMED!
                    self.trader.create_trade(order, self.volume)
                    self.orders_opening.append(order)
                    break
```

### Key Conditions for MACD Divergence BUY:

1. ✅ Swing low detected (POKE_POINT)
2. ✅ Price makes higher low (last > previous)
3. ✅ MACD makes lower low (divergence)
4. ✅ MACD delta > `delta_macd`
5. ✅ Price delta > `delta_price_pct`
6. ✅ Trend confirmed (n_trend_point analysis)
7. ✅ Risk/Reward ≥ `min_rr`
8. ✅ Reward ≥ `min_rw_pct`

---

## How to Identify Trading Points in Code

### Method 1: Check Order Creation

```python
# In strategy.check_signal()
if conditions_met:
    order = Order(...)
    order = self.trader.fix_order(order, sl_fix_mode, max_sl_pct)
    if order:  # ← Trading point confirmed here
        self.trader.create_trade(order, self.volume)
        self.orders_opening.append(order)
        # Trading point = order created successfully
```

### Method 2: Monitor Logs

```python
# In trader.create_trade()
bot_logger.info("   [+] Create new order, symbol: {}, strategy: {}".format(...))
bot_logger.info("    - {}".format(order))
# This log message = trading point detected
```

### Method 3: Check Order Lists

```python
# After backtest/live trading
strategy.orders_opening  # Currently active trading points
strategy.orders_closed   # Completed trading points (with PnL)
```

---

## Visualizing Trading Points

### 1. HTML Charts

After backtest, check the HTML files in `debug/{SYMBOL}/{strategy_name}.html`:

- **Green rectangles**: Profitable trades
- **Red rectangles**: Losing trades
- **White lines**: Entry points
- **Purple lines**: Trend lines used for entry

### 2. CSV Files

Check `debug/{SYMBOL}/{SYMBOL}_orders.csv`:

```csv
order_id,type,side,entry,tp,sl,status,reward_ratio,risk_ratio,rr
1,MARKET,BUY,1.0850,None,1.0820,HIT_TP,0.012,0.003,4.0
2,MARKET,SELL,1.0830,None,1.0860,HIT_SL,-0.003,0.003,-1.0
```

Each row = one trading point

---

## Practical Example: Finding Trading Points

### Example: Breakout Strategy on EURUSD 15m

```python
# Configuration
{
    "name": "break_strategy",
    "params": {
        "min_num_cuml": 10,      # Minimum 10 candles in consolidation
        "min_zz_pct": 0.5,       # 0.5% minimum zigzag move
        "zz_dev": 2.5,           # 2.5x multiplier for pattern
        "ma_vol": 25,            # 25-period volume MA
        "vol_ratio_ma": 1.8,     # Volume must be 1.8x MA
        "kline_body_ratio": 2.5, # Body must be 2.5x average
        "sl_fix_mode": "ADJ_SL"
    },
    "tfs": {"tf": "15m"},
    "max_sl_pct": 0.75,
    "volume": 0.01
}
```

### Trading Point Detection Process:

```
Candle 1-9:  Accumulating data, building ZigZag
Candle 10:   Consolidation pattern detected (10+ candles)
Candle 11:   Still in consolidation
Candle 12:   Volume spike detected! (1.8x MA)
             Strong green candle (body 2.5x average)
             Price breaks above down trend line
             Price above SMA(200)
             ✅ TRADING POINT! → BUY order created
```

---

## Debugging Trading Points

### Check Why Trading Point Was NOT Generated

```python
# Add debug logging in check_signal()
def check_signal(self):
    chart = self.tfs_chart[self.tf]
    last_kline = chart.iloc[-1]
    
    # Debug: Volume check
    volume_ok = last_kline["Volume"] >= self.params["vol_ratio_ma"] * self.ma_vol.iloc[-1]
    print(f"Volume check: {volume_ok} (Volume: {last_kline['Volume']}, Required: {self.params['vol_ratio_ma'] * self.ma_vol.iloc[-1]})")
    
    if not volume_ok:
        return  # Trading point blocked: Low volume
    
    # Debug: Pattern check
    # ... continue with other checks
```

### Verify Trading Points in Backtest

```python
# After backtest
for strategy in trader.strategies:
    print(f"\nStrategy: {strategy.name}")
    print(f"Total Trading Points: {len(strategy.orders_closed)}")
    print(f"Active Points: {len(strategy.orders_opening)}")
    
    for order in strategy.orders_closed[:5]:  # First 5 trading points
        print(f"  Order {order.order_id}: {order.side} @ {order.entry}, PnL: {order.get_PnL():.2%}")
```

---

## Key Parameters That Control Trading Points

### Breakout Strategy:
- `vol_ratio_ma`: Higher = fewer signals (more volume required)
- `min_num_cuml`: Higher = longer consolidation required
- `kline_body_ratio`: Higher = stronger candles required
- `zz_dev`: Higher = more strict pattern recognition

### MACD Divergence:
- `delta_macd`: Higher = more divergence required
- `delta_price_pct`: Higher = larger price moves required
- `min_rr`: Higher = better risk/reward required
- `n_last_point`: More = analyze more historical points

---

## Timing: When Trading Points Occur

### Real-Time:
- Trading points checked **every minute** (when new candle closes)
- Only on the strategy's specified timeframe(s)

### Backtesting:
- Trading points checked **for each historical candle**
- Simulates real-time detection

### Important:
- Trading points are **only checked on completed candles**
- No intra-candle signals (waits for candle close)

---

## Summary

**Trading Points = Entry Signals Generated When:**

1. ✅ Technical conditions are met (ZigZag, MACD, etc.)
2. ✅ Volume/pattern filters pass
3. ✅ Risk management validates the trade
4. ✅ Order is successfully created

**To Get Trading Points:**
- Run backtest or live trading
- Check `orders_closed` and `orders_opening` lists
- View HTML charts for visual confirmation
- Review CSV files for detailed data

**To Adjust Trading Points:**
- Modify strategy parameters in config
- Change `vol_ratio_ma`, `min_rr`, etc.
- Adjust `max_sl_pct` for risk tolerance

The system automatically detects trading points when market conditions match your strategy's criteria. No manual intervention needed - just configure parameters and let the system run!

